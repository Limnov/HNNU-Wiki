# 计算机基础

> 本页面介绍计算机硬件、系统和原理的基础知识，帮助你深入理解计算机的工作方式。

## 🎯 为什么要了解计算机基础？

**新手常见困惑：**
- "CPU和内存有什么区别？"
- "为什么要装操作系统？"
- "程序是怎么运行的？"
- "Linux和Windows有什么区别？"

**了解计算机基础的重要性：**
- ✅ 理解程序的运行原理
- ✅ 更好地进行性能优化
- ✅ 快速定位问题
- ✅ 选择合适的开发环境

---

## 🖥️ 计算机硬件组成

### CPU（中央处理器）

**定义**：计算机的大脑，负责执行指令和处理数据

#### CPU的核心参数

**1. 核心数（Core Count）**
- **4核**：基础办公
- **6核**：轻度开发、游戏
- **8核**：主流开发、专业工作
- **12核+**：重度开发、视频编辑、AI训练

**比喻**：核心数 = 工厂的车间数量
- 车间越多，同时处理的任务越多

**2. 频率（Clock Speed）**
- **2.0GHz**：基础性能
- **3.0GHz**：主流性能
- **4.0GHz+**：高性能
- **5.0GHz+**：极致性能（通过超频）

**比喻**：频率 = 工人的工作速度
- 频率越高，每个核心处理速度越快

**3. 缓存（Cache）**
- **L1缓存**：最小（几KB），最快
- **L2缓存**：中等（几百KB），较快
- **L3缓存**：最大（几MB到几十MB），较慢

**为什么需要缓存？**
```
CPU速度：    每秒数十亿次运算
内存速度：   每秒数亿次访问
硬盘速度：   每秒数千万次读写

缓存作为中间层，平衡速度差异
```

**4. 架构（Architecture）**
- **x86**：Intel、AMD主流架构
- **ARM**：移动设备、Apple M系列
- **RISC-V**：开源架构

**常见CPU系列：**

| 系列 | 特点 | 适用场景 |
|------|------|---------|
| **Intel 酷睿 i3** | 入门级 | 办公、轻度使用 |
| **Intel 酷睿 i5** | 主流 | 开发、游戏 |
| **Intel 酷睿 i7** | 高性能 | 专业开发、创作 |
| **Intel 酷睿 i9** | 极致性能 | 重度计算、AI |
| **AMD 锐龙 5** | 主流 | 开发、游戏 |
| **AMD 锐龙 7** | 高性能 | 专业工作 |
| **AMD 锐龙 9** | 极致性能 | 重度计算 |
| **Apple M1/M2/M3** | 高能效 | Mac专用 |

**编程中的CPU应用：**
- **编译代码**：多核CPU加速编译
- **并行计算**：利用多核心处理数据
- **虚拟机**：需要CPU虚拟化支持
- **AI训练**：需要高性能多核CPU

---

### 内存（RAM）

**定义**：临时存储数据的"工作台"，CPU的快速访问区域

#### 内存的特点

**1. 速度快**
- 读写速度：**10-30 GB/s**
- 硬盘速度：**100-500 MB/s**（HDD）
- 固态硬盘：**500-7000 MB/s**（SSD）
- **内存比硬盘快100倍以上**

**2. 易失性**
- **断电数据丢失**
- 这是特性，不是bug
- 需要硬盘永久存储

**3. 容量规格**
- **8GB**：基础办公
- **16GB**：开发推荐
- **32GB**：专业开发、AI
- **64GB+**：重度AI、视频编辑

#### 内存的比喻

```
图书馆比喻：
├─ 硬盘 = 书库（容量大，取书慢）
├─ 内存 = 阅览室（容量小，取书快）
└─ CPU  = 大脑（思考处理）
```

**工作流程：**
```
1. 从书库（硬盘）找书
2. 拿到阅览室（内存）
3. 在大脑（CPU）中阅读思考
```

#### 为什么内存不足会卡？

**问题场景：**
```
程序A需要 4GB内存
程序B需要 6GB内存
程序C需要 8GB内存
总计：18GB

但物理内存只有 16GB
```

**解决方案：虚拟内存（交换空间）**
- 使用硬盘空间模拟内存
- **速度慢100倍**
- 导致系统卡顿

**内存充足的好处：**
- 同时运行多个程序不卡
- 程序启动更快
- 编译大型项目更快
- 虚拟机运行更流畅

#### 内存类型

**DDR（Double Data Rate）系列：**

| 类型 | 频率 | 速度 | 特点 |
|------|------|------|------|
| **DDR3** | 1066-1866 MHz | 淘汰 | 老旧电脑 |
| **DDR4** | 2133-3200 MHz | 主流 | 当前主流 |
| **DDR5** | 4800-7200 MHz | 新一代 | 新电脑标配 |

#### 内存通道

**单通道 vs 双通道：**
```
单通道：1条64位通道
双通道：2条64位通道（带宽翻倍）

性能提升：20-40%
```

**建议：**
- 使用**2条或4条**内存组成双通道
- 容量相同、频率相同、型号相同

#### 编程中的内存管理

**内存泄漏（Memory Leak）：**
```python
# Python示例
def memory_leak():
    data = []
    while True:
        data.append([0] * 1000000)  # 不断占用内存
        # 内存永远不会释放

# 导致：内存耗尽，程序崩溃
```

**内存优化技巧：**
- 及时释放不需要的对象
- 使用生成器代替列表
- 避免创建大对象
- 使用对象池复用对象

---

### 硬盘（存储设备）

**定义**：永久存储数据的设备

#### 硬盘类型

**1. HDD（机械硬盘）**

**工作原理：**
- 磁盘旋转（5400/7200 RPM）
- 磁头读写数据
- 机械结构，有噪音

**优点：**
- 容量大（4TB+）
- 价格便宜（每GB成本低）
- 数据恢复相对容易

**缺点：**
- 速度慢（100-200 MB/s）
- 怕震动
- 有噪音
- 体积大

**适用场景：**
- 大容量数据存储
- 备份硬盘
- 监控录像存储

**2. SSD（固态硬盘）**

**工作原理：**
- 基于闪存（Flash Memory）
- 无机械部件
- 电子存储

**优点：**
- 速度快（500-7000 MB/s）
- 静音
- 抗震动
- 体积小
- 功耗低

**缺点：**
- 价格贵（每GB成本高）
- 数据恢复困难
- 有写入次数限制

**适用场景：**
- 系统盘
- 开发环境
- 游戏、应用程序

**3. NVMe SSD（高端固态）**

**接口：** PCIe通道（比SATA快）
- **SATA SSD**：500-600 MB/s
- **NVMe SSD**：2000-7000 MB/s

**速度对比：**
```
HDD:      ████████ 100 MB/s
SATA SSD: ████████████████████████ 500 MB/s
NVMe SSD: ████████████████████████████████ 3500 MB/s
```

#### 硬盘分区

**为什么需要分区？**
- 系统和数据分离
- 便于管理
- 提高效率

**推荐分区方案：**
```
Windows:
├─ C盘（系统盘）：150-256GB（SSD）
└─ D盘（数据盘）：剩余空间

macOS:
└─ 单个分区即可

Linux:
├─ /boot    : 500MB-1GB
├─ /        : 50-100GB（系统）
├─ /home    : 剩余空间（用户数据）
└─ swap     : 2-8GB（交换空间）
```

---

### 显卡（GPU）

**定义**：专门处理图形和图像计算的处理器

#### GPU的作用

**1. 图形渲染**
- 显示图像
- 渲染3D场景
- 视频输出

**2. 通用计算（GPGPU）**
- AI训练
- 深度学习
- 科学计算
- 密码破解

#### 独显 vs 核显

**集成显卡（核显）：**
- 集成在CPU中
- 共享系统内存
- 性能较弱
- 功耗低

**独立显卡（独显）：**
- 独立硬件
- 专用显存
- 性能强
- 功耗高

**常见GPU系列：**

| 系列 | 特点 | 适用场景 |
|------|------|---------|
| **Intel UHD** | 核显 | 办公、轻度开发 |
| **AMD Radeon** | 中端 | 游戏、创作 |
| **NVIDIA GTX** | 主流 | 游戏、AI入门 |
| **NVIDIA RTX** | 高端 | 3A游戏、AI训练 |
| **NVIDIA A100** | 专业 | 数据中心、AI研究 |

#### GPU编程

**CUDA（NVIDIA）：**
```python
# 使用CUDA加速Python代码
import cupy as cp

# GPU上的数组运算
x_gpu = cp.array([1, 2, 3, 4])
y_gpu = cp.array([5, 6, 7, 8])
z_gpu = x_gpu + y_gpu  # GPU并行计算
```

**应用场景：**
- 深度学习框架（PyTorch、TensorFlow）
- 数据科学计算
- 视频编解码
- 密码学计算

---

## 🖥️ 操作系统

### 操作系统的作用

**定义**：管理计算机硬件和软件资源的系统软件

**核心功能：**
1. **硬件管理**：CPU、内存、设备
2. **文件管理**：文件、目录
3. **进程管理**：程序运行
4. **用户界面**：人与计算机交互
5. **设备驱动**：硬件抽象

**没有操作系统的后果：**
- 直接控制硬件（极度复杂）
- 每个程序都要管理硬件
- 无法同时运行多个程序

---

### Windows

**开发商**：Microsoft

**版本历史：**
- Windows 95/98/XP（经典）
- Windows 7（优秀）
- Windows 8/8.1（失败）
- Windows 10（主流）
- Windows 11（最新）

**特点：**
- ✅ 用户最多，软件最丰富
- ✅ 游戏支持最好
- ✅ 兼容性强
- ✅ 界面友好
- ❌ 需要激活（收费）
- ❌ 系统臃肿
- ❌ 病毒风险相对高

**适用场景：**
- 游戏玩家
- 办公软件
- 一般用户
- .NET开发

**开发环境：**
- .NET/C#
- Windows桌面应用
- Unity游戏开发

**快捷键：**
- `Win + E`：打开文件资源管理器
- `Win + D`：显示桌面
- `Win + L`：锁定计算机
- `Ctrl + Shift + Esc`：任务管理器

---

### macOS

**开发商**：Apple

**版本：**
- macOS Big Sur（11）
- macOS Monterey（12）
- macOS Ventura（13）
- macOS Sonoma（14）
- macOS Sequoia（15）

**特点：**
- ✅ 界面美观，动画流畅
- ✅ 系统稳定，不易崩溃
- ✅ 开发体验极佳
- ✅ Unix核心（类Linux）
- ✅ 软件质量高
- ❌ 只能在Apple硬件上运行
- ❌ 硬件价格高
- ❌ 游戏相对少

**适用场景：**
- Web前端开发
- 移动开发（iOS）
- 设计师
- 创作者

**开发优势：**
- Unix命令行
- 包管理器（Homebrew）
- SSH、Git开箱即用
- Docker支持好

**开发工具：**
- Xcode（iOS开发）
- Homebrew（包管理）
- iTerm2（终端）

**Homebrew示例：**
```bash
# 安装软件
brew install git
brew install python
brew install node

# 搜索软件
brew search chrome
```

---

### Linux

**特点**：开源、免费、可定制

**核心特点：**
- ✅ 完全免费开源
- ✅ 高度可定制
- ✅ 安全性高
- ✅ 服务器主流
- ✅ 开发者友好
- ❌ 学习曲线陡
- ❌ 软件兼容性一般
- ❌ 游戏少

**主流发行版：**

| 发行版 | 特点 | 适用场景 | 难度 |
|--------|------|---------|------|
| **Ubuntu** | 用户友好，社区大 | 新手、桌面 | ⭐⭐ |
| **Linux Mint** | 界面像Windows | 新手 | ⭐ |
| **Fedora** | 新技术，稳定 | 开发者 | ⭐⭐⭐ |
| **Debian** | 稳定，老旧 | 服务器 | ⭐⭐⭐ |
| **CentOS** | 企业级，稳定 | 服务器 | ⭐⭐⭐⭐ |
| **Arch Linux** | 滚动更新，DIY | 高级用户 | ⭐⭐⭐⭐⭐ |
| **Kali** | 安全工具集合 | 安全测试 | ⭐⭐⭐⭐ |

**Linux目录结构：**
```
/          （根目录）
├─ /bin     （基本命令）
├─ /etc     （配置文件）
├─ /home    （用户目录）
├─ /root    （管理员目录）
├─ /usr     （软件安装）
├─ /var     （变量数据）
└─ /tmp     （临时文件）
```

**常用命令：**
```bash
# 文件操作
ls              # 列出文件
cd /home        # 切换目录
mkdir test      # 创建目录
rm file.txt     # 删除文件
cp a.txt b.txt  # 复制文件
mv a.txt b.txt  # 移动/重命名

# 系统管理
sudo apt update    # 更新软件源
sudo apt install git # 安装软件
systemctl status nginx # 查看服务状态
top                # 查看进程
df -h              # 查看磁盘
free -h            # 查看内存
```

**为什么程序员需要懂Linux？**
- 服务器大多是Linux
- Docker、K8s基于Linux
- 云平台（AWS、阿里云）用Linux
- 嵌入式开发用Linux
- Git、SSH等工具源自Linux

---

## 🧠 内存层次结构

### 存储金字塔

```
速度：快 → 慢
容量：小 → 大
价格：贵 → 便宜

    CPU寄存器
    （最快，最小，几KB）
        ↓
    CPU缓存
    （L1/L2/L3，几MB）
        ↓
    主内存
    （RAM，几GB到几十GB）
        ↓
    硬盘
    （HDD/SSD，几百GB到几TB）
        ↓
    网络存储
    （最慢，最大，无限）
```

### 为什么需要多级存储？

**问题：**
- CPU速度：**每秒数十亿次运算**
- 内存速度：**每秒数亿次访问**
- 硬盘速度：**每秒数千万次读写**

**速度差异：**
```
CPU > 缓存 > 内存 > 硬盘
```

**解决方案：**
- **缓存**：存储常用数据
- **预取**：提前加载数据
- **局部性原理**：程序倾向于访问邻近数据

### 32位 vs 64位

**32位系统：**
- 地址总线：32位
- 最大寻址：**4GB内存**
- 已经淘汰

**64位系统：**
- 地址总线：64位
- 最大寻址：**256TB内存**（理论）
- 当前主流

**如何查看：**
- Windows：设置 → 系统 → 关于
- macOS：关于本机 → 处理器
- Linux：`uname -m`
  - `x86_64` = 64位
  - `i686` = 32位

---

## ⚡ 进程和线程

### 进程（Process）

**定义**：正在运行的程序实例

**特点：**
- 独立的内存空间
- 进程间隔离
- 创建开销大
- 资源独立

**示例：**
```
打开Chrome = 1个进程
打开Word   = 1个进程
打开VS Code = 1个进程
```

**进程状态：**
```
创建 → 就绪 → 运行 → 阻塞 → 结束
         ↓                   ↓
      调度                等待I/O
```

**进程通信（IPC）：**
- 管道（Pipe）
- 消息队列
- 共享内存
- 套接字（Socket）

---

### 线程（Thread）

**定义**：进程内的执行单元

**特点：**
- 共享进程资源
- 轻量级
- 创建快
- 通信方便

**比喻：**
```
进程 = 工厂
线程 = 工人

工厂（进程）包含多个工人（线程）
工人共享工厂的资源
```

**多线程的好处：**
- 充分利用CPU
- 提高性能
- 同时处理多个任务
- 提升用户体验

**多线程示例：**
```python
import threading

def task1():
    print("任务1执行")

def task2():
    print("任务2执行")

# 创建两个线程
t1 = threading.Thread(target=task1)
t2 = threading.Thread(target=task2)

# 启动线程（并行执行）
t1.start()
t2.start()
```

---

### 进程 vs 线程

| 特性 | 进程 | 线程 |
|------|------|------|
| **内存** | 独立 | 共享 |
| **开销** | 大 | 小 |
| **通信** | 复杂 | 简单 |
| **安全性** | 高 | 低 |
| **创建速度** | 慢 | 快 |
| **数据共享** | 困难 | 容易 |

---

### 并发 vs 并行

**并发（Concurrent）：**
- 同时处理多个任务
- 时间片轮转
- 单核CPU也能并发

**并行（Parallel）：**
- 同时执行多个任务
- 多核CPU才能并行
- 真正的同时

```
单核CPU（只能并发）：
任务1 | 任务2 | 任务1 | 任务2 | ...
时间 →

双核CPU（可以并行）：
核心1：任务1 | 任务1 | 任务1 | ...
核心2：任务2 | 任务2 | 任务2 | ...
时间 →
```

---

## 🎛️ 二进制基础

### 为什么用二进制？

**原因：**
1. **硬件容易实现**
   - 开关两种状态：开/关
   - 高/低电平：1/0

2. **可靠性高**
   - 只有两个状态
   - 不容易出错

3. **运算简单**
   - 逻辑运算：与、或、非
   - 算术运算：加法器

**十进制 vs 二进制：**
```
十进制：0, 1, 2, 3, 4, 5, 6, 7, 8, 9
二进制：0, 1
```

---

### 位和字节

**位（Bit）：**
- 最小单位
- 表示0或1
- b是小写

**字节（Byte）：**
- **8位 = 1字节**
- 基本单位
- B是大写

**换算：**
```
1 Byte (B)  = 8 bits (b)
1 KB        = 1024 Bytes
1 MB        = 1024 KB
1 GB        = 1024 MB
1 TB        = 1024 GB
1 PB        = 1024 TB
```

**为什么是1024而不是1000？**
```
2^10 = 1024

计算机基于二进制，
所以用2的幂次
```

---

### 数制转换

**十进制转二进制：**
```
方法：除2取余

10 ÷ 2 = 5 ... 0
 5 ÷ 2 = 2 ... 1
 2 ÷ 2 = 1 ... 0
 1 ÷ 2 = 0 ... 1

从下往上：1010

所以：10(十进制) = 1010(二进制)
```

**二进制转十进制：**
```
1010(二进制)
= 1×2³ + 0×2² + 1×2¹ + 0×2⁰
= 8 + 0 + 2 + 0
= 10(十进制)
```

**常见数值：**
```
十进制  →  二进制
0       →  0
1       →  1
2       →  10
3       →  11
4       →  100
5       →  101
7       →  111
8       →  1000
15      →  1111
255     →  11111111
1024    →  10000000000
```

---

### 十六进制

**为什么需要十六进制？**
- 二进制太长
- 十六进制更紧凑
- 方便表示二进制

**符号：**
```
0, 1, 2, 3, 4, 5, 6, 7, 8, 9
A, B, C, D, E, F
(10, 11, 12, 13, 14, 15)
```

**转换：**
```
二进制   →  十六进制
0000    →  0
0001    →  1
1010    →  A
1111    →  F
11111111 →  FF
```

**编程中的表示：**
```python
# 十六进制
0xFF      # 255
0x10      # 16
0xABCD    # 43981

# 二进制
0b1010    # 10
0b1111    # 15
```

---

### 数据的存储

**整数存储：**
```
int（4字节，32位）
范围：-2³¹ 到 2³¹-1
大约：-21亿 到 21亿

long（8字节，64位）
范围：-2⁶³ 到 2⁶³-1
大约：-9×10¹⁸ 到 9×10¹⁸
```

**浮点数存储：**
```
float（4字节）
精度：约7位有效数字

double（8字节）
精度：约15位有效数字
```

**字符存储（ASCII）：**
```
'A' = 65  = 01000001
'B' = 66  = 01000010
'a' = 97  = 01100001
'0' = 48  = 00110000
```

**中文存储（UTF-8）：**
```
'中' = 3字节 = 11100100 10111000 10101101
```

---

## 📊 计算机工作原理

### 冯·诺依曼结构

**经典结构：**
```
┌──────────────────────────────┐
│         输入设备              │
│    （键盘、鼠标、摄像头）       │
└─────────────┬────────────────┘
              ↓
┌──────────────────────────────┐
│          存储器               │
│        (内存/硬盘)            │
│  - 存储程序                   │
│  - 存储数据                   │
└─────────────┬────────────────┘
              ↓
┌──────────────────────────────┐
│         运算器               │
│      - 算术运算               │
│      - 逻辑运算               │
└─────────────┬────────────────┘
              ↓
┌──────────────────────────────┐
│         控制器               │
│      - 指令译码               │
│      - 指令执行               │
└─────────────┬────────────────┘
              ↓
┌──────────────────────────────┐
│         输出设备              │
│    （显示器、打印机、音箱）     │
└──────────────────────────────┘
```

**核心思想：**
- **存储程序**：程序和数据都存储在内存中
- **顺序执行**：按顺序逐条执行指令

---

### 程序执行过程

**完整流程：**
```
1. 程序存储在硬盘
   example.py

2. 加载到内存
   操作系统读取程序

3. CPU从内存读取指令
   取指（Fetch）

4. 译码
   分析指令含义

5. 执行
   执行指令操作

6. 写回
   结果写回内存

7. 重复3-6
   直到程序结束
```

**时钟周期：**
- CPU有固定节奏
- 每个周期执行一步
- 3GHz = 每秒30亿个周期

---

### 操作系统如何管理程序？

**进程调度：**
```
时间片轮转：
进程A → 进程B → 进程C → 进程A → ...
（每段时间：几毫秒）
```

**内存管理：**
```
虚拟内存：
进程A以为有4GB
进程B以为有4GB
实际上物理内存可能只有8GB

操作系统负责映射
```

**文件系统：**
```
文件名 → inode → 数据块
管理：
- 创建
- 读取
- 写入
- 删除
```

---

## 🔋 性能优化

### CPU优化

**1. 利用多核**
```python
# 多进程利用多核
from multiprocessing import Pool

def process_data(data):
    # 处理数据
    return result

# 创建进程池
with Pool(4) as p:
    results = p.map(process_data, data_list)
```

**2. 减少CPU密集操作**
- 使用缓存
- 优化算法
- 减少循环嵌套
- 使用向量化操作

**3. CPU亲和性**
```python
# 绑定进程到特定CPU核心
import os
os.sched_setaffinity(0, {0, 1})  # 使用核心0和1
```

---

### 内存优化

**1. 减少内存占用**
```python
# 坏：创建大列表
data = [i for i in range(10000000)]

# 好：使用生成器
data = (i for i in range(10000000))
```

**2. 及时释放**
```python
# 使用后删除
large_data = process_big_data()
del large_data  # 释放内存
```

**3. 使用适当的数据结构**
```python
# 查找频繁：用字典（哈希表）
data = {}  # O(1)

# 顺序访问：用列表
data = []  # O(1)追加
```

**4. 避免内存泄漏**
```python
# 坏：循环引用
def memory_leak():
    data = []
    data.append(data)  # 引用自己
    return data

# 好：及时清理
def no_leak():
    data = []
    result = process(data)
    data.clear()  # 清空
    return result
```

---

### 磁盘优化

**1. 使用SSD**
- 速度提升10-100倍
- 开机更快
- 程序启动更快

**2. 批量读写**
```python
# 坏：频繁写入
for item in items:
    with open('data.txt', 'a') as f:
        f.write(str(item))

# 好：批量写入
with open('data.txt', 'w') as f:
    f.write('\n'.join(map(str, items)))
```

**3. 使用缓冲**
```python
# 增大缓冲区
with open('large_file.txt', 'r', buffering=1024*1024) as f:
    data = f.read()
```

---

## 🛡️ 计算机安全

### 恶意软件

**类型：**

**1. 病毒（Virus）**
- 依附于其他程序
- 自我复制
- 破坏数据

**2. 木马（Trojan）**
- 伪装成正常软件
- 窃取信息
- 开启后门

**3. 勒索软件（Ransomware）**
- 加密用户文件
- 勒索赎金
- 近年高发

**4. 广告软件（Adware）**
- 弹出广告
- 收集数据
- 影响体验

**防护措施：**
- ✅ 安装杀毒软件
- ✅ 不下载来路不明的软件
- ✅ 及时更新系统
- ✅ 警惕钓鱼邮件
- ✅ 定期备份重要数据

---

### 数据备份

**3-2-1原则：**
```
3份数据：原件 + 2个备份
2种介质：本地 + 云端
1个异地：异地备份（防火、防水）
```

**备份工具：**

**Windows：**
- 文件历史记录
- 备份和还原
- 第三方工具

**macOS：**
- Time Machine（时间机器）
- 自动增量备份

**云备份：**
- 百度网盘
- OneDrive
- Google Drive
- iCloud

**开发者备份：**
```bash
# 代码备份
git push origin main

# 数据库备份
mysqldump -u root -p database > backup.sql

# 文件同步
rsync -av /data/ /backup/
```

---

### 权限管理

**Linux权限：**
```
-rwxr-xr--
││││││││└─ 其他用户：读
││││││└─── 其他用户：执行
│││││└──── 其他用户：无写权限
││││└───── 组用户：读
│││└────── 组用户：执行
││└─────── 组用户：无写权限
│└──────── 所有者：读
└───────── 所有者：写
          └─ 所有者：执行

r = read（读）
w = write（写）
x = execute（执行）
- = 无权限
```

**修改权限：**
```bash
# 给所有者添加执行权限
chmod u+x script.sh

# 给所有人读写执行权限
chmod 777 file.txt

# 给所有者全部权限，其他人只读
chmod 744 file.txt
```

---

## 📚 学习资源

### 在线教程
- [计算机科学速成课 - B站](https://www.bilibili.com/)
- [Crash Course: Computer Science](https://www.youtube.com/crashcourse)
- [哈佛大学CS50](https://cs50.harvard.edu/)

### 书籍推荐
- 《编码：隐匿在计算机软硬件背后的语言》- 入门必读
- 《深入理解计算机系统》（CSAPP）- 经典教材
- 《计算机组成与设计》- 硬件基础
- 《现代操作系统》- 系统原理

### 实践建议
- 查看自己的电脑配置
- 使用任务管理器观察资源占用
- 安装Linux虚拟机体验
- 学习命令行操作

---

## ❓ 常见问题

### Q1: 需要很深的硬件知识吗？
**A**:
- **不需要**：了解基本概念即可
- **特殊方向**：嵌入式、驱动开发需要深入
- **大多数开发**：应用层开发够用

### Q2: 8GB内存够用吗？
**A**:
- **日常办公**：8GB够用
- **编程开发**：16GB推荐
- **游戏/AI**：32GB或更多
- **建议**：内存越大越好

### Q3: 必须学Linux吗？
**A**:
- **Web开发**：不是必须，但推荐
- **后端开发**：必须掌握
- **服务器运维**：必须精通
- **建议**：至少了解基本操作

### Q4: 如何选择操作系统？
**A**:
- **新手**：Windows（软件多）
- **Web开发**：macOS（体验好）
- **后端/服务器**：Linux（必须）
- **学生**：按专业要求

### Q5: CPU核心数越多越好吗？
**A**:
- **不是绝对**：还要看频率、架构
- **日常使用**：6-8核够用
- **专业工作**：12核+更好
- **建议**：核心数和频率平衡

### Q6: SSD和HDD哪个好？
**A**:
- **系统盘**：SSD（必须）
- **数据盘**：SSD（推荐）
- **备份盘**：HDD（便宜）
- **最佳**：SSD + HDD组合

---

## 💡 学习建议

1. **理解基本概念**
   - CPU、内存、硬盘的作用
   - 操作系统的功能
   - 二进制基础

2. **动手实践**
   - 查看电脑配置
   - 观察任务管理器
   - 了解资源占用
   - 使用命令行

3. **保持好奇心**
   - 了解原理更好
   - 有助于解决问题
   - 提升技术深度

4. **不需要过度深入**
   - 应用层开发够用
   - 除非做底层开发
   - 边用边学最有效

---

**下一步**：
- [数学基础](/知识扫盲/数学基础.md)
- [开发工具相关](/知识扫盲/开发工具相关.md)
- [互联网基础](/知识扫盲/互联网基础.md)
